---
title: CRUD Configs
description: Configuring CRUD operations in DartWay (Serverpod-based)
alwaysApply: true
---

# CRUD Configs

In DartWay, **all server logic must go through CRUD configs**.  
This ensures consistency, predictability, and AI-friendly code generation.

ðŸ‘‰ Unlike raw Serverpod, DartWay uses wrapper classes (`DwSaveConfig`, `DwDeleteConfig`, `DwGetModelConfig`, `DwGetListConfig`) where you provide callbacks for validation, processing, and side effects.  
ðŸ‘‰ All configs for a model are collected into a single **`DwCrudConfig<T>`**.

---

## ðŸ“¦ DwCrudConfig (entry point per model)

Each model must have a single **`DwCrudConfig<T>`** that aggregates all related configs.  
This is the **entry point for AI and developers** â€” all rules for a model are defined here.

```dart
final userProfileCrudConfig = DwCrudConfig<UserProfile>(
  table: UserProfile.t,
  getModelConfigs: [ ... ],
  getListConfig: ..., 
  saveConfig: ..., 
  deleteConfig: ..., 
);
```

- **`table`** â†’ required reference to the table.  
- **`getModelConfigs`** â†’ may contain multiple configs for different filters/rules.  
- **`getListConfig`** â†’ rules for lists.  
- **`saveConfig`** â†’ rules for insert/update.  
- **`deleteConfig`** â†’ rules for deletion.  

ðŸ‘‰ If a config is missing, the API will return `DwApiResponse.notConfigured`.

---

## ðŸŸ¦ DwGetModelConfig

**Purpose**: fetch a single model instance by filter.  
Allows multiple configs for the same model to support different access rules or projections.

### Parameters
- `filterPrototype` â†’ defines which requests this config applies to. Itâ€™s used to match incoming query filters with the correct config.
- `include` â†’ optional `Include` object for eager loading relations.
- `additionalEntitiesFetchFunction` â†’ function `(session, model) => [relatedModels]` to include extra related data in the response.
- `createIfMissing` â†’ function `(session, filter) => model` that creates an entity if not found.

### Behavior
1. Matches request against `filterPrototype` to decide if config applies.  
2. Fetches entity by filter.  
3. If not found â†’ optionally calls `createIfMissing`.  
4. Returns wrapped response with the found (or created) entity and additional related models.  

### Example
```dart
final userProfileGetConfig = DwGetModelConfig<UserProfile>(
  filterPrototype: DwBackendFilter(field: 'id'),
  include: UserProfile.include(
    address: Address.include(),
  ),
  additionalEntitiesFetchFunction: (session, model) async {
    return await session.db.find<BalanceEvent>(
      where: (t) => t.userProfileId.equals(model.id),
    );
  },
  createIfMissing: (session, filter) async {
    return UserProfile(id: filter.value as int, name: 'Guest User');
  },
);
```

---

## ðŸŸ¨ DwGetListConfig

**Purpose**: fetch a list of models with optional filters, ordering, pagination, and related data.

### Parameters
- `include` â†’ optional `Include` object for eager loading relations.
- `additionalModelsFetchFunction` â†’ function `(session, models) => [relatedModels]` to include extra related data for the returned list.
- `defaultOrderByList` â†’ default ordering if no explicit order is provided in the query.

### Behavior
1. Fetches models from DB with `whereClause`, `limit`, `offset`.
2. Orders results with `defaultOrderByList` if provided.
3. Wraps results in `DwModelWrapper`.
4. Optionally fetches additional related models via `additionalModelsFetchFunction`.

### Example
```dart
final userProfileListConfig = DwGetListConfig<UserProfile>(
  include: UserProfile.include(
    address: Address.include(),
  ),
  defaultOrderByList: [UserProfile.t.createdAt.desc()],
  additionalModelsFetchFunction: (session, models) async {
    return await session.db.find<BalanceEvent>(
      where: (t) => t.userProfileId.inSet(models.map((u) => u.id)),
    );
  },
);
```

---

## ðŸŸ© DwSaveConfig

**Purpose**: handle creation and update of models with permissions, validation, pre/post-processing, and side effects.

### Parameters
- `allowSave` â†’ required permission check for both insert & update.
- `validateSave` â†’ optional validation hook, returns error string or null.
- `beforeSave` â†’ optional pre-processing inside transaction, can modify model and return extra updates.
- `afterSave` â†’ optional post-processing inside transaction, can return additional updated models.
- `afterSaveSideEffects` â†’ optional async side effects outside transaction (notifications, background tasks).

### Behavior
1. Loads initial model (if update).  
2. Runs `allowSave` check â†’ must return true.  
3. Runs `validateSave` hook â†’ may return error.  
4. Runs inside transaction:  
   - Calls `beforeSave` (optional) â†’ modifies model & collects updates.  
   - Inserts or updates the row.  
   - Calls `afterSave` (optional) â†’ collects extra updates.  
5. Runs `afterSaveSideEffects` outside transaction (fire-and-forget).  
6. Returns `DwApiResponse` with saved model and all updated models wrapped.

### Example
```dart
final userProfileSaveConfig = DwSaveConfig<UserProfile>(
  allowSave: (session, initial, updated) async {
    // Only allow if email is unique
    final exists = await session.db.findFirstRow<UserProfile>(
      where: (t) => t.email.equals(updated.email) & t.id.notEquals(updated.id),
    );
    return exists == null;
  },
  validateSave: (session, initial, updated) async {
    if (updated.email.isEmpty) return 'Email cannot be empty';
    return null;
  },
  beforeSave: (session, transaction, initial, updated) async {
    // Normalize name before save
    final processed = updated.copyWith(
      name: updated.name.trim(),
    );
    return DwPreSaveResult(model: processed);
  },
  afterSave: (session, transaction, initial, saved, {beforeUpdates}) async {
    // Return balance events as extra updates
    final events = await session.db.find<BalanceEvent>(
      where: (t) => t.userProfileId.equals(saved.id),
    );
    return events.map((e) => DwModelWrapper(object: e)).toList();
  },
  afterSaveSideEffects: (session, initial, saved, {beforeUpdates, afterUpdates}) async {
    // Fire notification
    await AppNotifications.sendProfileUpdated(session, saved);
  },
);
```

---

## ðŸŸ¥ DwDeleteConfig

**Purpose**: handle safe deletion of models with permission checks and post-delete actions.

### Parameters
- `allowDelete` â†’ optional function `(session, model) => bool` to check if model can be deleted.
- `afterDelete` â†’ optional function `(session, model) => [relatedModels]` to return additional updates after deletion.

### Behavior
1. Loads model by id.  
   - If not found â†’ returns ok=true with warning (already deleted).  
2. If no `allowDelete` provided â†’ returns `notConfigured`.  
3. Runs `allowDelete` â†’ must return true.  
4. Deletes row inside DB.  
   - If `DatabaseException` occurs (e.g., FK constraints) â†’ returns error.
5. Returns `DwApiResponse` with `DwModelWrapper.deleted` and optionally related models from `afterDelete`.

### Example
```dart
final userProfileDeleteConfig = DwDeleteConfig<UserProfile>(
  allowDelete: (session, model) async {
    // Prevent deletion if user still has balance
    return model.balance <= 0;
  },
  afterDelete: (session, model) async {
    // Clean up associated balance events
    return await session.db.find<BalanceEvent>(
      where: (t) => t.userProfileId.equals(model.id),
    );
  },
);
```

---

## ðŸš¦ Workflow

1. Create or update a model in `/models`.  
2. Generate code:  
   ```bash
   dart run serverpod generate
   ```
3. Create a `DwCrudConfig<T>` in `/crud`.  
4. Implement validation, permissions, pre/post-processing.  
5. Add side effects where needed (wrap updates in `DwModelWrapper`).  
6. Write tests in `/test`.

---

## âš¡ Best Practices

- **Always use CRUD configs** â†’ never put logic directly in endpoints.  
- **One `DwCrudConfig` per model** â†’ single entry point for all rules.  
- **Keep configs small** â†’ validation, checks, and side effects only.  
- **Use `/domain`** for pure logic (extensions).  
- **Use `/app`** for workflows (session-aware services).  
- **Event models** for transactional flows.  
- **Side effects** go into `afterSave`, `afterDelete`, or dedicated `sideEffects`.  

---

## âœ… Key Takeaways

- CRUD configs (`DwCrudConfig`, `DwGetModelConfig`, etc.) are the **only allowed place** for server logic.  
- Every model must have one `DwCrudConfig` collecting all rules.  
- Keep them predictable and small.  
- Extend logic in `/domain` or `/app`, but always trigger through CRUD.  
- Event models + CRUD configs = safe, traceable business flows.  
- See also: [Serverpod Endpoints Docs](https://docs.serverpod.dev/docs/concepts/endpoints).